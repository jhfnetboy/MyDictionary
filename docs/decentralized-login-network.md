# å»ä¸­å¿ƒåŒ–æŒ‡çº¹ç™»å½•ç½‘ç»œ - è¯¦ç»†è®¾è®¡

## ğŸ¯ æ ¸å¿ƒåˆ›æ–°ï¼šPremium æŒ‡çº¹ç™»å½•

### é—®é¢˜èƒŒæ™¯
ä¼ ç»Ÿ Web3 ç™»å½•çš„ç—›ç‚¹ï¼š
1. **ç”¨æˆ·ä½“éªŒå·®**: æ¯æ¬¡æ“ä½œéƒ½è¦ MetaMask ç­¾å
2. **éšç§æ³„éœ²**: é’±åŒ…åœ°å€å®Œå…¨å…¬å¼€
3. **æ— æ³•é˜²å…±äº«**: ç­¾åå¯å¤åˆ¶åˆ°å…¶ä»–è®¾å¤‡
4. **ä¸­å¿ƒåŒ–ä¾èµ–**: éœ€è¦ RPC èŠ‚ç‚¹éªŒè¯

### è§£å†³æ–¹æ¡ˆï¼šæŒ‡çº¹ç™»å½• + å»ä¸­å¿ƒåŒ–ç¤¾åŒºéªŒè¯

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨æˆ·è®¾å¤‡                                â”‚
â”‚  1. ç”ŸæˆæŒ‡çº¹ (Canvas + WebGL + Audio)   â”‚
â”‚  2. é’±åŒ…ç­¾åæŒ‡çº¹                         â”‚
â”‚  3. æœ¬åœ°ç¼“å­˜å‡­è¯ (24h)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“ (é¦–æ¬¡ / è¿‡æœŸæ—¶)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å»ä¸­å¿ƒåŒ–éªŒè¯ç½‘ç»œ (ç¤¾åŒºèŠ‚ç‚¹)            â”‚
â”‚  - 10+ èŠ‚ç‚¹åˆ†å¸ƒå¼éªŒè¯                   â”‚
â”‚  - æ£€æŸ¥é“¾ä¸Šè®¢é˜…çŠ¶æ€                     â”‚
â”‚  - éªŒè¯ç­¾åæœ‰æ•ˆæ€§                       â”‚
â”‚  - è¿”å›è§£å¯†å¯†é’¥                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ™ºèƒ½åˆçº¦ (é“¾ä¸ŠçŠ¶æ€)                    â”‚
â”‚  - è®¢é˜… NFT æ‰€æœ‰æƒ                      â”‚
â”‚  - è®¾å¤‡ç™½åå• (fingerprint hash)        â”‚
â”‚  - èŠ‚ç‚¹ä¿¡èª‰åˆ†æ•°                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸŒ å»ä¸­å¿ƒåŒ–éªŒè¯ç½‘ç»œæ¶æ„

### èŠ‚ç‚¹ç±»å‹

#### 1. éªŒè¯èŠ‚ç‚¹ (Validator Node)
**èŒè´£**:
- æ¥æ”¶ç”¨æˆ·éªŒè¯è¯·æ±‚
- æŸ¥è¯¢é“¾ä¸Šè®¢é˜…çŠ¶æ€
- éªŒè¯ç­¾åæœ‰æ•ˆæ€§
- è¿”å›è§£å¯†å¯†é’¥

**è¦æ±‚**:
- è´¨æŠ¼ 100 PNTS Token (é˜²å¥³å·«æ”»å‡»)
- è¿è¡Œæ—¶é—´ > 95% (ä¿¡èª‰è¯„åˆ†)
- å“åº”æ—¶é—´ < 500ms

**æ”¶ç›Š**:
- æ¯æ¬¡éªŒè¯: 0.001 PNTS (ä»è®¢é˜…è´¹ä¸­åˆ†é…)
- æœˆå‡æ”¶å…¥: ~$50 (å‡è®¾ 5000 æ¬¡éªŒè¯/å¤©)

#### 2. ç´¢å¼•èŠ‚ç‚¹ (Indexer Node)
**èŒè´£**:
- åŒæ­¥é“¾ä¸Šè®¢é˜…æ•°æ®
- ç¼“å­˜è®¾å¤‡ç™½åå•
- æä¾›å¿«é€ŸæŸ¥è¯¢æ¥å£

**è¦æ±‚**:
- è´¨æŠ¼ 500 PNTS
- å­˜å‚¨ç©ºé—´ > 50 GB
- å¸¦å®½ > 100 Mbps

**æ”¶ç›Š**:
- æ¯æ¬¡æŸ¥è¯¢: 0.0001 PNTS
- æœˆå‡æ”¶å…¥: ~$20

#### 3. æ•°æ®èŠ‚ç‚¹ (Data Node)
**èŒè´£**:
- Pin IPFS æ•°æ®
- æä¾›æ•°æ®ä¸‹è½½æœåŠ¡
- ä¿è¯æ•°æ®å¯ç”¨æ€§

**è¦æ±‚**:
- è´¨æŠ¼ 200 PNTS
- å­˜å‚¨ç©ºé—´ > 100 GB
- ä¸Šä¼ å¸¦å®½ > 50 Mbps

**æ”¶ç›Š**:
- æ¯ GB å­˜å‚¨/æœˆ: 0.5 PNTS
- æœˆå‡æ”¶å…¥: ~$30

---

## ğŸ” æŒ‡çº¹ç™»å½•åè®®ï¼ˆè¯¦ç»†æµç¨‹ï¼‰

### Phase 1: é¦–æ¬¡ç»‘å®š

```javascript
// 1. ç”¨æˆ·è´­ä¹°è®¢é˜…åï¼Œé¦–æ¬¡æ‰“å¼€æ’ä»¶

async function firstTimeSetup() {
  // 1.1 ç”Ÿæˆè®¾å¤‡æŒ‡çº¹
  const fingerprint = await generateDeviceFingerprint();
  const fingerprintHash = sha256(fingerprint);

  console.log('è®¾å¤‡æŒ‡çº¹:', fingerprintHash);

  // 1.2 è¿æ¥é’±åŒ…
  const wallet = await connectWallet();
  const walletAddress = await wallet.getAddress();

  // 1.3 æ£€æŸ¥é“¾ä¸Šè®¢é˜…çŠ¶æ€
  const hasSubscription = await contract.hasActiveSubscription(walletAddress);

  if (!hasSubscription) {
    throw new Error('è¯·å…ˆè´­ä¹°è®¢é˜…');
  }

  // 1.4 é’±åŒ…ç­¾åè®¾å¤‡æŒ‡çº¹ï¼ˆè¯æ˜è®¾å¤‡æ‰€æœ‰æƒï¼‰
  const message = `MyDictionary Device Binding\n\nFingerprint: ${fingerprintHash}\nTimestamp: ${Date.now()}`;
  const signature = await wallet.signMessage(message);

  console.log('ç­¾å:', signature);

  // 1.5 æäº¤åˆ°æ™ºèƒ½åˆçº¦æ³¨å†Œè®¾å¤‡
  const tx = await contract.registerDevice(fingerprintHash, signature);
  await tx.wait();

  console.log('âœ… è®¾å¤‡å·²ç»‘å®šåˆ°è®¢é˜…');

  // 1.6 è¯·æ±‚éªŒè¯å‡­è¯
  const credential = await requestVerificationCredential(
    fingerprintHash,
    signature,
    walletAddress
  );

  // 1.7 æœ¬åœ°ç¼“å­˜å‡­è¯ï¼ˆ24 å°æ—¶ï¼‰
  await storage.set('premiumCredential', credential, { ttl: 86400000 });

  return credential;
}
```

### Phase 2: æ—¥å¸¸éªŒè¯ï¼ˆæ— æ„Ÿç™»å½•ï¼‰

```javascript
// 2. ç”¨æˆ·åç»­æ‰“å¼€æ’ä»¶ï¼ˆ24 å°æ—¶å†…ï¼‰

async function verifyPremiumAccess() {
  // 2.1 æ£€æŸ¥æœ¬åœ°ç¼“å­˜
  const cachedCredential = await storage.get('premiumCredential');

  if (cachedCredential && !isExpired(cachedCredential)) {
    console.log('âœ… ä½¿ç”¨ç¼“å­˜å‡­è¯ï¼ˆæ— æ„Ÿç™»å½•ï¼‰');
    return {
      valid: true,
      credential: cachedCredential,
      method: 'cached'
    };
  }

  // 2.2 å‡­è¯è¿‡æœŸï¼Œé‡æ–°éªŒè¯
  console.log('â° å‡­è¯å·²è¿‡æœŸï¼Œè¯·æ±‚æ–°å‡­è¯');

  const fingerprint = await generateDeviceFingerprint();
  const fingerprintHash = sha256(fingerprint);

  // 2.3 å‘é€åˆ°å»ä¸­å¿ƒåŒ–éªŒè¯ç½‘ç»œ
  const credential = await requestVerificationFromNetwork(fingerprintHash);

  // 2.4 æ›´æ–°æœ¬åœ°ç¼“å­˜
  await storage.set('premiumCredential', credential, { ttl: 86400000 });

  return {
    valid: true,
    credential: credential,
    method: 'network'
  };
}
```

### Phase 3: å»ä¸­å¿ƒåŒ–éªŒè¯ï¼ˆç½‘ç»œå±‚ï¼‰

```javascript
// 3. éªŒè¯ç½‘ç»œå¤„ç†è¯·æ±‚

// 3.1 å®¢æˆ·ç«¯ï¼šå‘é€éªŒè¯è¯·æ±‚åˆ°å¤šä¸ªèŠ‚ç‚¹
async function requestVerificationFromNetwork(fingerprintHash) {
  // è·å–æ´»è·ƒéªŒè¯èŠ‚ç‚¹åˆ—è¡¨
  const nodes = await getActiveValidatorNodes();

  // å¹¶è¡Œè¯·æ±‚ 3 ä¸ªèŠ‚ç‚¹ï¼ˆé˜²æ­¢å•ç‚¹æ•…éšœï¼‰
  const requests = nodes.slice(0, 3).map(node =>
    axios.post(`${node.endpoint}/verify`, {
      fingerprintHash: fingerprintHash,
      timestamp: Date.now()
    })
  );

  // ç­‰å¾…è‡³å°‘ 2/3 èŠ‚ç‚¹å“åº”
  const responses = await Promise.allSettled(requests);
  const validResponses = responses
    .filter(r => r.status === 'fulfilled' && r.value.data.valid)
    .map(r => r.value.data);

  if (validResponses.length < 2) {
    throw new Error('éªŒè¯å¤±è´¥ï¼šèŠ‚ç‚¹å“åº”ä¸è¶³');
  }

  // éªŒè¯èŠ‚ç‚¹è¿”å›çš„å‡­è¯ä¸€è‡´æ€§
  const credential = validResponses[0].credential;
  const allMatch = validResponses.every(r =>
    r.credential === credential
  );

  if (!allMatch) {
    throw new Error('éªŒè¯å¤±è´¥ï¼šèŠ‚ç‚¹ç»“æœä¸ä¸€è‡´');
  }

  return credential;
}

// 3.2 éªŒè¯èŠ‚ç‚¹ï¼šå¤„ç†éªŒè¯è¯·æ±‚
async function handleVerificationRequest(req, res) {
  const { fingerprintHash, timestamp } = req.body;

  // æ£€æŸ¥æ—¶é—´æˆ³ï¼ˆé˜²é‡æ”¾æ”»å‡»ï¼‰
  if (Math.abs(Date.now() - timestamp) > 60000) {
    return res.status(400).json({ error: 'Invalid timestamp' });
  }

  // æŸ¥è¯¢é“¾ä¸Šæ•°æ®ï¼ˆä½¿ç”¨æœ¬åœ°ç´¢å¼•åŠ é€Ÿï¼‰
  const deviceInfo = await indexer.getDeviceInfo(fingerprintHash);

  if (!deviceInfo) {
    return res.status(404).json({ error: 'Device not registered' });
  }

  // éªŒè¯è®¢é˜…çŠ¶æ€
  const subscription = await indexer.getSubscription(deviceInfo.owner);

  if (!subscription.active || subscription.expiryTime < Date.now()) {
    return res.status(403).json({ error: 'Subscription expired' });
  }

  // ç”ŸæˆéªŒè¯å‡­è¯ï¼ˆJWTï¼‰
  const credential = jwt.sign(
    {
      fingerprintHash: fingerprintHash,
      subscriptionTier: subscription.tier,
      expiresAt: Date.now() + 86400000 // 24 å°æ—¶
    },
    NODE_PRIVATE_KEY,
    { algorithm: 'ES256' }
  );

  // è¿”å›å‡­è¯ + è§£å¯†å¯†é’¥
  return res.json({
    valid: true,
    credential: credential,
    decryptionKeys: {
      academicPhrases: subscription.keys.academicPhrases,
      ttsVoices: subscription.keys.ttsVoices,
      aiModel: subscription.keys.aiModel
    }
  });
}
```

---

## ğŸ† èŠ‚ç‚¹æ¿€åŠ±æœºåˆ¶

### æ”¶ç›Šåˆ†é…æ¨¡å‹

```
è®¢é˜…æ”¶å…¥: $9.9/å¹´/ç”¨æˆ·
    â†“
åˆ†é…æ–¹æ¡ˆ:
  - 70% â†’ å¼€å‘å›¢é˜Ÿ ($6.93)
  - 20% â†’ éªŒè¯èŠ‚ç‚¹å¥–æ±  ($1.98)
  - 10% â†’ æ•°æ®èŠ‚ç‚¹å¥–æ±  ($0.99)
```

### èŠ‚ç‚¹æ”¶ç›Šè®¡ç®—

```javascript
// æ™ºèƒ½åˆçº¦ï¼šæ¯æœˆåˆ†é…èŠ‚ç‚¹å¥–åŠ±

contract NodeRewards {
    mapping(address => NodeStats) public nodeStats;

    struct NodeStats {
        uint256 validations;      // éªŒè¯æ¬¡æ•°
        uint256 uptime;           // åœ¨çº¿æ—¶é•¿
        uint256 dataServed;       // æ•°æ®æœåŠ¡é‡ï¼ˆå­—èŠ‚ï¼‰
        uint256 reputationScore;  // ä¿¡èª‰åˆ†æ•° (0-100)
    }

    function distributeMonthlyRewards() public {
        uint256 totalRewardPool = address(this).balance;

        // éªŒè¯èŠ‚ç‚¹å¥–æ±  (20%)
        uint256 validatorPool = totalRewardPool * 20 / 100;

        // æŒ‰è´¡çŒ®åº¦åˆ†é…
        address[] memory validators = getActiveValidators();
        for (uint i = 0; i < validators.length; i++) {
            address validator = validators[i];
            uint256 score = calculateContributionScore(validator);
            uint256 reward = validatorPool * score / getTotalScore();

            payable(validator).transfer(reward);
        }

        // æ•°æ®èŠ‚ç‚¹å¥–æ±  (10%)
        uint256 dataNodePool = totalRewardPool * 10 / 100;
        // ... ç±»ä¼¼é€»è¾‘
    }

    function calculateContributionScore(address node) public view returns (uint256) {
        NodeStats memory stats = nodeStats[node];

        // åŠ æƒè®¡ç®—
        return (
            stats.validations * 50 +       // éªŒè¯æ¬¡æ•°æƒé‡ 50%
            stats.uptime * 30 +            // åœ¨çº¿æ—¶é•¿æƒé‡ 30%
            stats.reputationScore * 20     // ä¿¡èª‰åˆ†æ•°æƒé‡ 20%
        );
    }
}
```

### æœˆæ”¶ç›Šç¤ºä¾‹

å‡è®¾æœ‰ **500 ä¸ªä»˜è´¹ç”¨æˆ·**ï¼Œ**10 ä¸ªéªŒè¯èŠ‚ç‚¹**ï¼š

```
æœˆè®¢é˜…æ”¶å…¥: 500 Ã— $9.9 / 12 = $412.5
éªŒè¯èŠ‚ç‚¹å¥–æ± : $412.5 Ã— 20% = $82.5

å•èŠ‚ç‚¹æœˆæ”¶ç›Šï¼ˆå¹³å‡ï¼‰: $82.5 / 10 = $8.25
å¹´æ”¶ç›Š: $8.25 Ã— 12 = $99
```

**ROI åˆ†æ**:
- è´¨æŠ¼æˆæœ¬: 100 PNTS â‰ˆ $50
- æœåŠ¡å™¨æˆæœ¬: $5/æœˆ
- å¹´å‡€æ”¶ç›Š: $99 - $60 = $39
- ROI: 78% (å¯è¡Œ)

---

## ğŸ”’ å®‰å…¨æ€§è®¾è®¡

### 1. é˜²å¥³å·«æ”»å‡»ï¼ˆSybil Attackï¼‰

**é—®é¢˜**: æ¶æ„èŠ‚ç‚¹å¤§é‡æ³¨å†Œï¼Œæ§åˆ¶éªŒè¯ç½‘ç»œ

**é˜²å¾¡**:
```solidity
contract ValidatorRegistry {
    uint256 public constant MIN_STAKE = 100 * 10**18; // 100 PNTS

    mapping(address => bool) public isValidator;
    uint256 public totalValidators;

    function registerValidator() public payable {
        require(msg.value >= MIN_STAKE, "Insufficient stake");
        require(!isValidator[msg.sender], "Already registered");

        isValidator[msg.sender] = true;
        totalValidators++;
    }

    // æƒ©ç½šä½œæ¶èŠ‚ç‚¹
    function slashValidator(address validator, string memory reason) public onlyGovernance {
        require(isValidator[validator], "Not a validator");

        // æ²¡æ”¶è´¨æŠ¼
        uint256 slashed = stakes[validator];
        stakes[validator] = 0;
        isValidator[validator] = false;

        // åˆ†é…ç»™ä¸¾æŠ¥è€…
        payable(msg.sender).transfer(slashed / 2);
    }
}
```

### 2. é˜²é‡æ”¾æ”»å‡»ï¼ˆReplay Attackï¼‰

**é—®é¢˜**: æ”»å‡»è€…æˆªè·éªŒè¯è¯·æ±‚ï¼Œé‡å¤å‘é€

**é˜²å¾¡**:
```javascript
// å®¢æˆ·ç«¯ï¼šç”Ÿæˆå”¯ä¸€ nonce
const nonce = crypto.randomBytes(32).toString('hex');
const timestamp = Date.now();

const request = {
  fingerprintHash,
  nonce,
  timestamp,
  signature: sign({ fingerprintHash, nonce, timestamp })
};

// éªŒè¯èŠ‚ç‚¹ï¼šæ£€æŸ¥ nonce
const usedNonces = new Set();

function validateRequest(request) {
  // æ£€æŸ¥æ—¶é—´æˆ³ï¼ˆ60 ç§’å†…æœ‰æ•ˆï¼‰
  if (Math.abs(Date.now() - request.timestamp) > 60000) {
    throw new Error('Request expired');
  }

  // æ£€æŸ¥ nonce æ˜¯å¦å·²ä½¿ç”¨
  if (usedNonces.has(request.nonce)) {
    throw new Error('Duplicate request');
  }

  usedNonces.add(request.nonce);

  // 60 ç§’åæ¸…ç† nonce
  setTimeout(() => usedNonces.delete(request.nonce), 60000);
}
```

### 3. é˜²ä¸­é—´äººæ”»å‡»ï¼ˆMITMï¼‰

**é—®é¢˜**: æ”»å‡»è€…æ‹¦æˆªéªŒè¯è¯·æ±‚/å“åº”

**é˜²å¾¡**:
```javascript
// ä½¿ç”¨ HTTPS + è¯ä¹¦éªŒè¯
const axios = require('axios');
const https = require('https');

const httpsAgent = new https.Agent({
  rejectUnauthorized: true,  // å¿…é¡»éªŒè¯è¯ä¹¦
  ca: [NODE_CA_CERT]         // éªŒè¯èŠ‚ç‚¹è¯ä¹¦é“¾
});

const response = await axios.post(nodeEndpoint, request, {
  httpsAgent,
  timeout: 5000
});

// éªŒè¯å“åº”ç­¾å
const isValid = verifySignature(
  response.data.credential,
  response.data.signature,
  NODE_PUBLIC_KEY
);

if (!isValid) {
  throw new Error('Invalid node signature');
}
```

---

## ğŸš€ èŠ‚ç‚¹éƒ¨ç½²æŒ‡å—

### è¿è¡ŒéªŒè¯èŠ‚ç‚¹

#### 1. ç¯å¢ƒè¦æ±‚
```yaml
ç¡¬ä»¶:
  CPU: 2 æ ¸
  RAM: 4 GB
  å­˜å‚¨: 50 GB SSD
  ç½‘ç»œ: 100 Mbps

è½¯ä»¶:
  OS: Ubuntu 22.04 LTS
  Node.js: v20.x
  PostgreSQL: 15.x
  Docker: 24.x
```

#### 2. å®‰è£…æ­¥éª¤

```bash
# å…‹éš†éªŒè¯èŠ‚ç‚¹ä»£ç 
git clone https://github.com/jhfnetboy/MyDictionary-Validator.git
cd MyDictionary-Validator

# å®‰è£…ä¾èµ–
npm install

# é…ç½®ç¯å¢ƒå˜é‡
cp .env.example .env
nano .env
```

```env
# .env é…ç½®æ–‡ä»¶

# èŠ‚ç‚¹è®¾ç½®
NODE_TYPE=validator
NODE_ENDPOINT=https://validator.yourdomain.com

# è´¨æŠ¼é’±åŒ…
WALLET_PRIVATE_KEY=your_private_key
STAKE_AMOUNT=100

# åŒºå—é“¾ RPC
POLYGON_RPC=https://polygon-rpc.com

# æ•°æ®åº“
DATABASE_URL=postgresql://user:password@localhost:5432/validator

# IPFS
IPFS_GATEWAY=https://ipfs.io/ipfs/
```

```bash
# è´¨æŠ¼ Token æ³¨å†ŒèŠ‚ç‚¹
npm run register-validator

# å¯åŠ¨éªŒè¯èŠ‚ç‚¹
npm run start

# ä½¿ç”¨ PM2 ç®¡ç†è¿›ç¨‹
pm2 start npm --name "validator" -- start
pm2 save
pm2 startup
```

#### 3. ç›‘æ§å’Œç»´æŠ¤

```bash
# æŸ¥çœ‹æ—¥å¿—
pm2 logs validator

# æŸ¥çœ‹çŠ¶æ€
curl http://localhost:3000/health

# æŸ¥çœ‹æ”¶ç›Š
npm run check-rewards
```

---

## ğŸ“Š ç½‘ç»œç›‘æ§å’Œæ²»ç†

### èŠ‚ç‚¹ç›‘æ§ä»ªè¡¨æ¿

**æŒ‡æ ‡**:
- æ´»è·ƒèŠ‚ç‚¹æ•°é‡
- å¹³å‡å“åº”æ—¶é—´
- éªŒè¯æˆåŠŸç‡
- ç½‘ç»œå¥åº·åº¦

**ç¤ºä¾‹ API**:
```javascript
GET /api/network/stats

{
  "totalNodes": 15,
  "activeNodes": 12,
  "avgResponseTime": 350,  // ms
  "successRate": 99.2,     // %
  "totalValidations": 125000,
  "networkHealth": "healthy"
}
```

### DAO æ²»ç†

**æ²»ç†äº‹é¡¹**:
- èŠ‚ç‚¹æœ€ä½è´¨æŠ¼é‡‘é¢
- æ”¶ç›Šåˆ†é…æ¯”ä¾‹
- èŠ‚ç‚¹æƒ©ç½šè§„åˆ™
- åè®®å‡çº§

**æŠ•ç¥¨æƒé‡**:
- è®¢é˜…ç”¨æˆ·: 1 ç¥¨
- éªŒè¯èŠ‚ç‚¹: 10 ç¥¨
- å¼€å‘å›¢é˜Ÿ: Veto æƒï¼ˆä»…ç”¨äºå®‰å…¨é—®é¢˜ï¼‰

---

## ğŸ¯ ç”¨æˆ·ä½“éªŒå¯¹æ¯”

### ä¼ ç»Ÿé’±åŒ…ç™»å½• vs æŒ‡çº¹ç™»å½•

#### åœºæ™¯ 1: é¦–æ¬¡ä½¿ç”¨

**ä¼ ç»Ÿæ–¹å¼**:
```
1. ç‚¹å‡»"Connect Wallet"
2. MetaMask å¼¹çª— â†’ é€‰æ‹©è´¦æˆ· â†’ ç¡®è®¤
3. ç­¾åæ¶ˆæ¯ â†’ MetaMask å¼¹çª— â†’ ç¡®è®¤
4. ç­‰å¾…åŒºå—é“¾ç¡®è®¤ï¼ˆ10-30 ç§’ï¼‰
5. å®Œæˆ

æ€»è€—æ—¶: ~45 ç§’
ç”¨æˆ·æ“ä½œ: 4 æ¬¡ç‚¹å‡»
```

**æŒ‡çº¹ç™»å½•**:
```
1. ç‚¹å‡»"Enable Premium"
2. MetaMask å¼¹çª— â†’ ç­¾åä¸€æ¬¡
3. åå°ç”ŸæˆæŒ‡çº¹ï¼ˆç”¨æˆ·æ— æ„Ÿï¼‰
4. è‡ªåŠ¨éªŒè¯å¹¶ç¼“å­˜

æ€»è€—æ—¶: ~5 ç§’
ç”¨æˆ·æ“ä½œ: 1 æ¬¡ç‚¹å‡»
```

#### åœºæ™¯ 2: æ—¥å¸¸ä½¿ç”¨

**ä¼ ç»Ÿæ–¹å¼**:
```
æ¯æ¬¡æ‰“å¼€æ’ä»¶:
1. æ£€æŸ¥é’±åŒ…è¿æ¥
2. ç­¾åéªŒè¯ï¼ˆå¼¹çª—ï¼‰
3. æŸ¥è¯¢é“¾ä¸ŠçŠ¶æ€

æ€»è€—æ—¶: ~10 ç§’/æ¬¡
çƒ¦äººç¨‹åº¦: â­â­â­â­â­
```

**æŒ‡çº¹ç™»å½•**:
```
æ¯æ¬¡æ‰“å¼€æ’ä»¶:
1. è¯»å–ç¼“å­˜å‡­è¯
2. åå°éªŒè¯ï¼ˆæ— æ„Ÿï¼‰

æ€»è€—æ—¶: ~0.5 ç§’
çƒ¦äººç¨‹åº¦: â­ (24 å°æ—¶å†…æ— æ„Ÿ)
```

---

## ğŸ’¡ æŠ€æœ¯ä¼˜åŠ¿æ€»ç»“

### å¯¹æ¯”å…¶ä»–æ–¹æ¡ˆ

| æ–¹æ¡ˆ | å»ä¸­å¿ƒåŒ– | ç”¨æˆ·ä½“éªŒ | éšç§ä¿æŠ¤ | é˜²å…±äº« | ç»´æŠ¤æˆæœ¬ |
|------|---------|---------|---------|--------|---------|
| ä¼ ç»Ÿé’±åŒ…ç™»å½• | âœ… | â­â­ | â­â­â­ | âŒ | ä½ |
| ä¸­å¿ƒåŒ– API Key | âŒ | â­â­â­â­ | â­â­ | âœ… | é«˜ |
| JWT + OAuth | âŒ | â­â­â­â­ | â­â­ | â­â­ | é«˜ |
| **æŒ‡çº¹ç™»å½• + å»ä¸­å¿ƒåŒ–ç½‘ç»œ** | âœ… | â­â­â­â­â­ | â­â­â­â­ | âœ… | ä½ |

### åˆ›æ–°ç‚¹

1. **ç”¨æˆ·ä½“éªŒé©å‘½æ€§æå‡**: 24 å°æ—¶å†…å®Œå…¨æ— æ„Ÿç™»å½•
2. **çœŸæ­£çš„å»ä¸­å¿ƒåŒ–**: ç¤¾åŒºèŠ‚ç‚¹éªŒè¯ï¼Œæ— ä¸­å¿ƒåŒ–æœåŠ¡å™¨
3. **éšç§å‹å¥½**: åŒ¿åæŒ‡çº¹ï¼Œä¸æ³„éœ²é’±åŒ…åœ°å€
4. **ç»æµæ¿€åŠ±**: ç¤¾åŒºèŠ‚ç‚¹è·å¾—æ”¶ç›Šï¼Œå½¢æˆæ­£å‘å¾ªç¯
5. **é˜²å…±äº«è®¾è®¡**: è®¾å¤‡æŒ‡çº¹ç»‘å®šï¼ŒæŠ€æœ¯ä¸Šéš¾ä»¥å…±äº«

---

## ğŸ—ºï¸ å®æ–½è·¯çº¿å›¾

### Phase 1: MVPï¼ˆ4 å‘¨ï¼‰
- [ ] æŒ‡çº¹ç”Ÿæˆå’Œç­¾å
- [ ] æ™ºèƒ½åˆçº¦ï¼ˆè®¾å¤‡æ³¨å†Œï¼‰
- [ ] å•èŠ‚ç‚¹éªŒè¯æœåŠ¡å™¨
- [ ] æœ¬åœ°å‡­è¯ç¼“å­˜

### Phase 2: å»ä¸­å¿ƒåŒ–ï¼ˆ4 å‘¨ï¼‰
- [ ] å¤šèŠ‚ç‚¹éƒ¨ç½²ï¼ˆ3-5 ä¸ªï¼‰
- [ ] èŠ‚ç‚¹æ³¨å†Œå’Œè´¨æŠ¼
- [ ] è´Ÿè½½å‡è¡¡å’Œæ•…éšœè½¬ç§»
- [ ] ç›‘æ§ä»ªè¡¨æ¿

### Phase 3: æ¿€åŠ±å’Œæ²»ç†ï¼ˆ4 å‘¨ï¼‰
- [ ] æ”¶ç›Šåˆ†é…åˆçº¦
- [ ] DAO æ²»ç†æ¨¡å—
- [ ] èŠ‚ç‚¹æƒ©ç½šæœºåˆ¶
- [ ] ç¤¾åŒºæŠ•ç¥¨ç³»ç»Ÿ

### Phase 4: ä¼˜åŒ–å’Œæ¨å¹¿ï¼ˆæŒç»­ï¼‰
- [ ] æ€§èƒ½ä¼˜åŒ–ï¼ˆ<300ms å“åº”ï¼‰
- [ ] èŠ‚ç‚¹æ–‡æ¡£å’Œæ•™ç¨‹
- [ ] èŠ‚ç‚¹è¿è¥è€…æ‹›å‹Ÿ
- [ ] å®¡è®¡å’Œå®‰å…¨åŠ å›º

---

## ğŸ“ æ€»ç»“

### æ ¸å¿ƒä»·å€¼
1. **ç”¨æˆ·**: ä¸€æ¬¡è®¾ç½®ï¼Œ24 å°æ—¶æ— æ„Ÿä½¿ç”¨
2. **å¼€å‘è€…**: æ— éœ€ç»´æŠ¤ä¸­å¿ƒåŒ–æœåŠ¡å™¨
3. **ç¤¾åŒº**: è¿è¡ŒèŠ‚ç‚¹è·å¾—æ”¶ç›Š
4. **ç½‘ç»œ**: å»ä¸­å¿ƒåŒ–ï¼ŒæŠ—å®¡æŸ¥ï¼Œå¯æŒç»­

### æŠ€æœ¯çªç ´
- é¦–ä¸ªå°†è®¾å¤‡æŒ‡çº¹ç”¨äº Web3 ç™»å½•çš„æ–¹æ¡ˆ
- ç¤¾åŒºéªŒè¯ç½‘ç»œæ›¿ä»£ä¸­å¿ƒåŒ–æœåŠ¡å™¨
- ç»æµæ¿€åŠ±ç¡®ä¿ç½‘ç»œå¯æŒç»­è¿è¡Œ

### å•†ä¸šæ½œåŠ›
- å¯æ‰©å±•åˆ°å…¶ä»– Web3 åº”ç”¨ï¼ˆé€šç”¨ç™»å½•åè®®ï¼‰
- èŠ‚ç‚¹è¿è¥æˆä¸ºæ–°çš„æ”¶å…¥æ¥æº
- é™ä½ Web3 åº”ç”¨çš„è¿è¥æˆæœ¬

---

## ğŸ” ä¸æ—¶é—´é”åŠ å¯†çš„é…åˆ

è¯¦è§: [ä»˜è´¹ç‰ˆæœ¬è®¡åˆ’](./payment-version-plan.md#ä¸æŒ‡çº¹ç™»å½•çš„é›†æˆ)

### å¯†é’¥åˆ†å‘å®‰å…¨æ€§

**æŒ‘æˆ˜**: éªŒè¯èŠ‚ç‚¹å¦‚ä½•å®‰å…¨åœ°å­˜å‚¨å’Œåˆ†å‘è§£å¯†å¯†é’¥?

**æ–¹æ¡ˆ**: å¤šç­¾ + é—¨é™å¯†é’¥å…±äº«

```javascript
// ä½¿ç”¨ Shamir's Secret Sharing (SSS)
import { split, combine } from 'shamirs-secret-sharing';

// 1. æ¯å‘¨å¯†é’¥åˆ†ç‰‡ (5 ä¸ªåˆ†ç‰‡,è‡³å°‘ 3 ä¸ªå¯æ¢å¤)
async function distributeWeeklyKey(weekNumber, masterKey) {
  const shares = split(Buffer.from(masterKey, 'hex'), {
    shares: 5,
    threshold: 3
  });

  // åˆ†å‘åˆ° 5 ä¸ªä¸åŒçš„éªŒè¯èŠ‚ç‚¹
  const nodes = await getTopValidators(5);
  for (let i = 0; i < 5; i++) {
    await nodes[i].storeKeyShare(weekNumber, shares[i]);
  }

  console.log(`âœ… Week ${weekNumber} key distributed to 5 nodes`);
}

// 2. ç”¨æˆ·éªŒè¯æ—¶,ä»è‡³å°‘ 3 ä¸ªèŠ‚ç‚¹è·å–åˆ†ç‰‡
async function reconstructKeyFromNodes(weekNumber) {
  const nodes = await getActiveValidators();

  // å¹¶è¡Œè¯·æ±‚å¤šä¸ªèŠ‚ç‚¹
  const shareRequests = nodes.slice(0, 4).map(node =>
    axios.post(`${node.endpoint}/get-key-share`, { weekNumber })
  );

  const responses = await Promise.allSettled(shareRequests);
  const validShares = responses
    .filter(r => r.status === 'fulfilled')
    .map(r => r.value.data.share);

  if (validShares.length < 3) {
    throw new Error('æ— æ³•è·å–è¶³å¤Ÿçš„å¯†é’¥åˆ†ç‰‡');
  }

  // æ¢å¤å®Œæ•´å¯†é’¥
  const masterKey = combine(validShares.slice(0, 3));
  return masterKey.toString('hex');
}
```

**ä¼˜åŠ¿**:
- âœ… å•èŠ‚ç‚¹è¢«æ”»ç ´ä¸æ³„éœ²å¯†é’¥
- âœ… éƒ¨åˆ†èŠ‚ç‚¹ç¦»çº¿ä¸å½±å“æœåŠ¡
- âœ… å®Œå…¨å»ä¸­å¿ƒåŒ–,æ— å•ç‚¹æ•…éšœ

### é˜²æ­¢å¯†é’¥æ³„éœ²çš„ç»æµæœºåˆ¶

**é—®é¢˜**: æ¶æ„èŠ‚ç‚¹å¯èƒ½æ³„éœ²å¯†é’¥ç»™éè®¢é˜…ç”¨æˆ·

**æ–¹æ¡ˆ**: è´¨æŠ¼ + æŒ‘æˆ˜æœºåˆ¶

```solidity
// ValidatorStaking.sol

contract ValidatorStaking {
    uint256 public constant STAKE_AMOUNT = 100 * 10**18; // 100 PNTS
    uint256 public constant SLASH_AMOUNT = 50 * 10**18;  // 50 PNTS

    mapping(address => uint256) public stakes;

    // æŒ‘æˆ˜æœºåˆ¶: ä»»ä½•äººå¯ä¸¾æŠ¥å¯†é’¥æ³„éœ²
    function challengeKeyLeak(
        address validator,
        uint256 weekNumber,
        bytes32 leakedKey,
        address[] memory nonSubscriberAddresses
    ) public {
        // 1. éªŒè¯ leakedKey ç¡®å®æ˜¯è¯¥å‘¨çš„å¯†é’¥
        require(
            keccak256(abi.encodePacked(leakedKey)) ==
            weeklyKeyHashes[weekNumber],
            "Invalid key"
        );

        // 2. éªŒè¯ nonSubscriberAddresses ç¡®å®æ²¡æœ‰è®¢é˜…
        for (uint i = 0; i < nonSubscriberAddresses.length; i++) {
            require(
                !hasActiveSubscription(nonSubscriberAddresses[i]),
                "Address has subscription"
            );
        }

        // 3. æƒ©ç½šéªŒè¯èŠ‚ç‚¹
        uint256 slashed = SLASH_AMOUNT;
        stakes[validator] -= slashed;

        // 4. å¥–åŠ±ä¸¾æŠ¥è€…
        payable(msg.sender).transfer(slashed / 2);

        emit ValidatorSlashed(validator, weekNumber, slashed);
    }

    // å­˜å‚¨æ¯å‘¨å¯†é’¥å“ˆå¸Œ (ç”¨äºéªŒè¯)
    mapping(uint256 => bytes32) public weeklyKeyHashes;

    function publishWeeklyKeyHash(uint256 weekNumber, bytes32 keyHash) public onlyOwner {
        weeklyKeyHashes[weekNumber] = keyHash;
    }
}
```

**ç»æµåšå¼ˆ**:
- æ³„éœ²å¯†é’¥æŸå¤±: $25 (50 PNTS / 2)
- æ³„éœ²å¯†é’¥æ”¶ç›Š: < $5 (å–ç»™å°‘æ•°äºº)
- **ç»“è®º**: ä¸ç»æµ âŒ

---

## ğŸŒ è·¨é“¾å…¼å®¹æ€§

### é—®é¢˜

å½“å‰è®¾è®¡åŸºäº Polygon,å¦‚ä½•æ”¯æŒå…¶ä»–é“¾?

### æ–¹æ¡ˆ: LayerZero è·¨é“¾æ¶ˆæ¯

```solidity
// SubscriptionNFT.sol (Polygon)

import "@layerzerolabs/contracts/interfaces/ILayerZeroEndpoint.sol";

contract SubscriptionNFT is ERC721, ILayerZeroReceiver {
    ILayerZeroEndpoint public endpoint;

    // è·¨é“¾åŒæ­¥è®¢é˜…çŠ¶æ€
    function syncSubscriptionToChain(
        uint16 dstChainId,  // ç›®æ ‡é“¾ ID (Arbitrum, Base, etc.)
        uint256 tokenId
    ) public payable {
        require(ownerOf(tokenId) == msg.sender, "Not owner");

        // ç¼–ç è®¢é˜…ä¿¡æ¯
        bytes memory payload = abi.encode(
            msg.sender,
            tokenId,
            subscriptionExpiry[tokenId]
        );

        // å‘é€è·¨é“¾æ¶ˆæ¯
        endpoint.send{value: msg.value}(
            dstChainId,
            abi.encodePacked(address(this)),
            payload,
            payable(msg.sender),
            address(0),
            bytes("")
        );
    }

    // æ¥æ”¶è·¨é“¾æ¶ˆæ¯
    function lzReceive(
        uint16 srcChainId,
        bytes memory srcAddress,
        uint64 nonce,
        bytes memory payload
    ) external override {
        require(msg.sender == address(endpoint), "Invalid endpoint");

        (address user, uint256 tokenId, uint256 expiry) = abi.decode(
            payload,
            (address, uint256, uint256)
        );

        // åœ¨æœ¬é“¾è®°å½•è®¢é˜…çŠ¶æ€
        crossChainSubscriptions[user] = Subscription({
            sourceChain: srcChainId,
            tokenId: tokenId,
            expiryTime: expiry,
            isActive: true
        });

        emit CrossChainSubscriptionSynced(srcChainId, user, tokenId);
    }
}
```

**éªŒè¯èŠ‚ç‚¹æŸ¥è¯¢é€»è¾‘**:
```javascript
async function checkSubscription(userAddress) {
  // å¹¶è¡ŒæŸ¥è¯¢å¤šæ¡é“¾
  const chains = [
    { id: 137, name: 'Polygon', rpc: 'https://polygon-rpc.com' },
    { id: 42161, name: 'Arbitrum', rpc: 'https://arb1.arbitrum.io/rpc' },
    { id: 8453, name: 'Base', rpc: 'https://mainnet.base.org' }
  ];

  const queries = chains.map(async (chain) => {
    const provider = new ethers.JsonRpcProvider(chain.rpc);
    const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider);
    return await contract.hasActiveSubscription(userAddress);
  });

  const results = await Promise.allSettled(queries);

  // ä»»ä¸€é“¾æœ‰è®¢é˜…å³å¯
  return results.some(r => r.status === 'fulfilled' && r.value === true);
}
```

---

## ğŸ“± ç§»åŠ¨ç«¯æ”¯æŒ

### æŒ‘æˆ˜

ç§»åŠ¨æµè§ˆå™¨æŒ‡çº¹ç¨³å®šæ€§è¾ƒä½ (iOS Safari é™åˆ¶ Canvas/WebGL)

### æ–¹æ¡ˆ: æ··åˆèº«ä»½éªŒè¯

```javascript
// æ¡Œé¢ç«¯: æŒ‡çº¹ç™»å½• (Canvas + WebGL + Audio)
if (isMobile()) {
  // ç§»åŠ¨ç«¯: ç®€åŒ–æŒ‡çº¹ + çŸ­æœŸé’±åŒ…ç­¾å
  const mobileFingerprint = {
    userAgent: navigator.userAgent,
    screen: `${screen.width}x${screen.height}`,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    language: navigator.language,
    platform: navigator.platform
  };

  // æ¯å‘¨é‡æ–°ç­¾åä¸€æ¬¡ (è€Œéæ¯æ¬¡)
  const weekNumber = getCurrentWeekNumber();
  const cachedSig = await storage.get(`mobileSig_${weekNumber}`);

  if (cachedSig) {
    return cachedSig; // ä½¿ç”¨ç¼“å­˜ç­¾å
  } else {
    const signature = await wallet.signMessage(`Week ${weekNumber}`);
    await storage.set(`mobileSig_${weekNumber}`, signature, { ttl: 604800000 }); // 7 å¤©
    return signature;
  }
} else {
  // æ¡Œé¢ç«¯: å®Œæ•´æŒ‡çº¹
  return await generateDeviceFingerprint();
}
```

---

## ğŸ”„ èŠ‚ç‚¹è½¯ä»¶æ›´æ–°æœºåˆ¶

### æŒ‘æˆ˜

å¦‚ä½•ç¡®ä¿æ‰€æœ‰éªŒè¯èŠ‚ç‚¹è¿è¡Œæœ€æ–°ç‰ˆæœ¬?

### æ–¹æ¡ˆ: é“¾ä¸Šç‰ˆæœ¬æ£€æŸ¥ + è‡ªåŠ¨æ›´æ–°

```solidity
// ValidatorRegistry.sol

contract ValidatorRegistry {
    struct NodeInfo {
        string endpoint;
        string version;      // "1.2.3"
        uint256 lastSeen;
        bool isActive;
    }

    mapping(address => NodeInfo) public nodes;

    string public requiredVersion = "1.2.0";
    uint256 public gracePeriod = 7 days;

    // èŠ‚ç‚¹å¿ƒè·³
    function heartbeat(string memory currentVersion) public {
        require(nodes[msg.sender].isActive, "Not registered");

        nodes[msg.sender].lastSeen = block.timestamp;
        nodes[msg.sender].version = currentVersion;

        // æ£€æŸ¥ç‰ˆæœ¬
        if (!isVersionCompatible(currentVersion, requiredVersion)) {
            emit NodeOutdated(msg.sender, currentVersion, requiredVersion);
        }
    }

    // æ›´æ–°æœ€ä½ç‰ˆæœ¬è¦æ±‚
    function updateRequiredVersion(string memory newVersion) public onlyOwner {
        requiredVersion = newVersion;
        emit VersionRequirementUpdated(newVersion, block.timestamp + gracePeriod);
    }

    // åœç”¨è¿‡æœŸèŠ‚ç‚¹
    function pruneOutdatedNodes() public {
        // è‡ªåŠ¨åœç”¨è¿‡æœŸèŠ‚ç‚¹...
    }
}
```

**éªŒè¯èŠ‚ç‚¹è‡ªåŠ¨æ›´æ–°**:
```javascript
// validator-node/auto-updater.js

const { exec } = require('child_process');

async function checkForUpdates() {
  const latestVersion = await contract.requiredVersion();
  const currentVersion = require('./package.json').version;

  if (compareVersions(latestVersion, currentVersion) > 0) {
    console.log(`â¬†ï¸  æ–°ç‰ˆæœ¬å¯ç”¨: ${latestVersion}`);

    // ä¸‹è½½æ–°ç‰ˆæœ¬
    exec('git pull origin main', (error, stdout) => {
      if (error) {
        console.error('æ›´æ–°å¤±è´¥:', error);
        return;
      }

      // é‡å¯æœåŠ¡
      exec('pm2 restart validator', () => {
        console.log('âœ… å·²æ›´æ–°åˆ°', latestVersion);
      });
    });
  }
}

// æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡
setInterval(checkForUpdates, 3600000);
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.1
**æœ€åæ›´æ–°**: 2025-12-01
**çŠ¶æ€**: æ–¹æ¡ˆè®¾è®¡é˜¶æ®µï¼ˆæœªå¼€å‘ï¼‰
**ä¸‹ä¸€æ­¥**: ç­‰å¾…ç¡®è®¤åå¼€å§‹æ™ºèƒ½åˆçº¦å¼€å‘
